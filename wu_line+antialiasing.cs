/***********************************************************************
This code is generated by the AlgoPascal translator

This code is distributed under the ALGLIB license
    (see http://www.alglib.net/copyrules.php for details)
***********************************************************************/
/*
This routines must be defined by the programmer:
static void setpixel(int x,
    int y,
    double alpha)
*/


/*************************************************************************
<<<<<<< HEAD
Ð Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ Ð»Ð¸Ð½Ð¸Ð¸ Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ Ð¼ÐµÑ‚Ð¾Ð´Ð° Ð’Ñƒ Ð´Ð»Ñ
Ð°Ð½Ñ‚Ð¸Ð°Ð»Ð¸Ð°ÑÐ¸Ð½Ð³Ð°.

ÐšÐ¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ñ‹ Ð½Ð°Ñ‡Ð°Ð»Ð° Ð¸ ÐºÐ¾Ð½Ñ†Ð° Ð¼Ð¾Ð³ÑƒÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð´Ñ€Ð¾Ð±Ð½Ñ‹Ð¼Ð¸.
=======
Ðèñîâàíèå ëèíèè ñ èñïîëüçîâàíèåì ìåòîäà Âó äëÿ
àíòèàëèàñèíãà.

Êîðäèíàòû íà÷àëà è êîíöà ìîãóò áûòü äðîáíûìè.
>>>>>>> 58e3d87... Added Wu's antialiasing algorithms for circle, ellipsis, line
*************************************************************************/
public static void drawwuline(double x1,
    double y1,
    double x2,
    double y2)
{
    double grad = 0;
    double xd = 0;
    double yd = 0;
    double length = 0;
    double xm = 0;
    double ym = 0;
    double xgap = 0;
    double ygap = 0;
    double xend = 0;
    double yend = 0;
    double xf = 0;
    double yf = 0;
    double brightness1 = 0;
    double brightness2 = 0;
    int x = 0;
    int y = 0;
    int ix1 = 0;
    int ix2 = 0;
    int iy1 = 0;
    int iy2 = 0;
    bool wasexchange = new bool();
    int tmpint = 0;
    double tmpreal = 0;


    xd = x2-x1;
    yd = y2-y1;
    if( xd==0 & yd==0 )
    {
        return;
    }
    if( Math.Abs(xd)>Math.Abs(yd) )
    {
        wasexchange = false;
    }
    else
    {
        wasexchange = true;
        tmpreal = x1;
        x1 = y1;
        y1 = tmpreal;
        tmpreal = x2;
        x2 = y2;
        y2 = tmpreal;
        tmpreal = xd;
        xd = yd;
        yd = tmpreal;
    }
    if( x1>x2 )
    {
        tmpreal = x1;
        x1 = x2;
        x2 = tmpreal;
        tmpreal = y1;
        y1 = y2;
        y2 = tmpreal;
        xd = x2-x1;
        yd = y2-y1;
    }
    grad = yd/xd;
    xend = (int)Math.Floor(x1+0.5);
    yend = y1+grad*(xend-x1);
    xgap = 1-myfrac(x1+0.5);
    ix1 = (int)Math.Floor(x1+0.5);
    iy1 = (int)Math.Floor(yend);
    brightness1 = (1-myfrac(yend))*xgap;
    brightness2 = myfrac(yend)*xgap;
    if( wasexchange )
    {
        setpixel(iy1, ix1, brightness1);
        setpixel(iy1+1, ix1, brightness2);
    }
    else
    {
        setpixel(ix1, iy1, brightness1);
        setpixel(ix1, iy1+1, brightness2);
    }
    yf = yend+grad;
    xend = (int)Math.Floor(x2+0.5);
    yend = y2+grad*(xend-x2);
    xgap = 1-myfrac(x2-0.5);
    ix2 = (int)Math.Floor(x2+0.5);
    iy2 = (int)Math.Floor(yend);
    brightness1 = (1-myfrac(yend))*xgap;
    brightness2 = myfrac(yend)*xgap;
    if( wasexchange )
    {
        setpixel(iy2, ix2, brightness1);
        setpixel(iy2+1, ix2, brightness2);
    }
    else
    {
        setpixel(ix2, iy2, brightness1);
        setpixel(ix2, iy2+1, brightness2);
    }
    for(x=ix1+1; x<=ix2-1; x++)
    {
        brightness1 = 1-myfrac(yf);
        brightness2 = myfrac(yf);
        if( wasexchange )
        {
            setpixel((int)Math.Floor(yf), x, brightness1);
            setpixel((int)Math.Floor(yf)+1, x, brightness2);
        }
        else
        {
            setpixel(x, (int)Math.Floor(yf), brightness1);
            setpixel(x, (int)Math.Floor(yf)+1, brightness2);
        }
        yf = yf+grad;
    }
}


private static double myfrac(double x)
{
    double result = 0;


    result = x-(int)Math.Floor(x);
    return result;
}
